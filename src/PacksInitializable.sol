// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {UUPSUpgradeable} from "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";
import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {MEAccessControlUpgradeable} from "./common/MEAccessControlUpgradeable.sol";
import {PacksSignatureVerifierUpgradeable} from "./common/PacksSignatureVerifierUpgradeable.sol";
import {IPRNG} from "./common/interfaces/IPRNG.sol";
import {TokenRescuer} from "./common/TokenRescuer.sol";

contract PacksInitializable is
    MEAccessControlUpgradeable,
    PausableUpgradeable,
    PacksSignatureVerifierUpgradeable,
    ReentrancyGuardUpgradeable,
    UUPSUpgradeable,
    TokenRescuer
{
    IPRNG public PRNG;
    address payable public feeReceiver;

    CommitData[] public packs;
    mapping(bytes32 commitDigest => uint256 commitId) public commitIdByDigest;

    uint256 public treasuryBalance; // The contract balance
    uint256 public commitBalance; // The open commit balances

    uint256 public commitExpireTime = 10 minutes;
    mapping(uint256 commitId => uint256 expiresAt) public commitExpiresAt;

    uint256 public constant MIN_COMMIT_EXPIRE_TIME = 1 minutes;

    bytes32 public constant FEE_RECEIVER_MANAGER_ROLE = keccak256("FEE_RECEIVER_MANAGER_ROLE");

    mapping(address cosigner => bool active) public isCosigner;
    mapping(address receiver => uint256 counter) public packCount;
    mapping(uint256 commitId => bool fulfilled) public isFulfilled;
    mapping(uint256 commitId => bool expired) public isExpired;

    uint256 public payoutBps; // When user selects payout as reward
    uint256 public minReward; // Min reward for a commit (whether it's NFT or payout)
    uint256 public maxReward; // Max reward for a commit (whether it's NFT or payout)
    uint256 public minPackPrice; // Min pack price for a commit
    uint256 public maxPackPrice; // Max pack price for a commit

    // Storage gap for future upgrades
    uint256[50] private __gap;

    // bucketsHash is BucketData[] hashed
    // digest is CommitData hashed
    // bucketsSignature is the bucketsHash signed by the cosigner to authenticate the buckets used in the pack
    event Commit(
        address indexed sender,
        uint256 indexed commitId,
        address indexed receiver,
        address cosigner,
        uint256 seed,
        uint256 counter,
        uint256 packPrice,
        bytes32 bucketsHash,
        bytes32 digest
    );
    event CosignerAdded(address indexed cosigner);
    event CosignerRemoved(address indexed cosigner);
    // rng is random number generated by PRNG in bps
    // bucketIndex is the index of the bucket selected by rng
    // odds is the odds of the bucket selected by rng
    // bucketIndex is the index of the bucket selected by rng
    // payout is > 0 if payout is chosen, 0 if NFT is chosen
    // token, tokenId, tokenAmount are the NFT reward details,nullish if user choses payout
    // digest is CommitData hashed
    event Fulfillment(
        address indexed sender,
        uint256 indexed commitId,
        uint256 rng,
        uint256 odds,
        uint256 bucketIndex,
        uint256 payout,
        address token,
        uint256 tokenId,
        uint256 amount,
        address receiver,
        bytes32 digest
    );
    event MaxRewardUpdated(uint256 oldMaxReward, uint256 newMaxReward);
    event Withdrawal(address indexed sender, uint256 amount, address feeReceiver);
    event Deposit(address indexed sender, uint256 amount);
    event MinRewardUpdated(uint256 oldMinReward, uint256 newMinReward);
    event CommitExpireTimeUpdated(uint256 oldCommitExpireTime, uint256 newCommitExpireTime);
    event CommitExpired(uint256 indexed commitId, bytes32 digest);
    event FeeReceiverUpdated(address indexed oldFeeReceiver, address indexed newFeeReceiver);
    event FeeReceiverManagerTransferred(address indexed oldFeeReceiverManager, address indexed newFeeReceiverManager);
    event TransferFailure(uint256 indexed commitId, address indexed receiver, uint256 amount, bytes32 digest);

    error AlreadyCosigner();
    error AlreadyFulfilled();
    error InsufficientBalance();
    error InvalidAmount();
    error InvalidCommitOwner();
    error InvalidBuckets();
    error InvalidBucketIndex();
    error InvalidPackHash();
    error InvalidCosigner();
    error InvalidReceiver();
    error InvalidReward();
    error FulfillmentFailed();
    error InvalidCommitId();
    error WithdrawalFailed();
    error InvalidCommitExpireTime();
    error CommitIsExpired();
    error CommitNotExpired();
    error TransferFailed();
    error InvalidFeeReceiver();
    error InvalidFeeReceiverManager();
    error InitialOwnerCannotBeZero();
    error NewImplementationCannotBeZero();

    modifier onlyCommitOwnerOrCosigner(uint256 commitId_) {
        if (packs[commitId_].receiver != msg.sender && packs[commitId_].cosigner != msg.sender) {
            revert InvalidCommitOwner();
        }
        _;
    }

    /// @dev Disables initializers for the implementation contract.
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the contract and handles any pre-existing balance
    /// @dev Sets up EIP712 domain separator and deposits any ETH sent during deployment
    function initialize(address initialOwner_, address feeReceiver_, address prng_, address feeReceiverManager_)
        public
        initializer
    {
        if (initialOwner_ == address(0)) revert InitialOwnerCannotBeZero();

        __MEAccessControl_init(initialOwner_);
        __Pausable_init();
        __PacksSignatureVerifier_init("Packs", "1");
        __ReentrancyGuard_init();

        uint256 existingBalance = address(this).balance;
        if (existingBalance > 0) {
            _depositTreasury(existingBalance);
        }

        _setFeeReceiver(feeReceiver_);
        PRNG = IPRNG(prng_);
        _grantRole(FEE_RECEIVER_MANAGER_ROLE, feeReceiverManager_);

        // Initialize reward limits
        payoutBps = 9000;
        minReward = 0.01 ether;
        maxReward = 5 ether;

        minPackPrice = 0.01 ether;
        maxPackPrice = 0.25 ether;
    }

    /// @dev Overriden to prevent unauthorized upgrades.
    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {
        if (newImplementation == address(0)) revert NewImplementationCannotBeZero();
    }

    /// @notice Allows a user to commit funds for a pack purchase
    /// @param receiver_ Address that will receive the NFT/ETH if won
    /// @param cosigner_ Address of the authorized cosigner
    /// @param seed_ Random seed for the commit
    /// @param buckets_ Buckets used in the pack
    /// @param signature_ Signature is the cosigned hash of packPrice + buckets[]
    /// @dev Emits a Commit event on success
    /// @return commitId The ID of the created commit
    function commit(
        address receiver_,
        address cosigner_,
        uint256 seed_,
        bytes32 packHash_,
        BucketData[] memory buckets_,
        bytes32 signature_
    ) public payable whenNotPaused returns (uint256) {
        // Amount user is sending to purchase the pack
        uint256 amount = msg.value;

        if (amount == 0) revert InvalidAmount();
        if (amount < minPackPrice) revert InvalidAmount();
        if (amount > maxPackPrice) revert InvalidAmount();

        if (!isCosigner[cosigner_]) revert InvalidCosigner();
        if (cosigner_ == address(0)) revert InvalidCosigner();
        if (receiver_ == address(0)) revert InvalidReceiver();

        if (buckets_.length == 0) revert InvalidBuckets();

        uint256 minReward_ = buckets_[0].minValue;
        uint256 maxReward_ = buckets_[buckets_.length - 1].maxValue;

        if (minReward_ == 0) revert InvalidReward();
        if (maxReward_ == 0) revert InvalidReward();
        if (minReward_ > maxReward_) revert InvalidReward();
        if (maxReward_ > maxReward) revert InvalidReward();
        if (minReward_ < minReward) revert InvalidReward();

        // Validate pack hash
        bytes32 packHash = hashPack(amount, buckets_);
        // TODO: Potentially superfluous as caller controls all inputs
        if (packHash_ != packHash) revert InvalidPackHash();

        // Verify pack hash signature
        address cosigner = _verifyPackHash(packHash, signature_);
        // TODO: Potentially superfluous as caller controls all inputs
        if (cosigner != cosigner_) revert InvalidCosigner();
        // Ensure pack data was signed by approved cosigner
        if (!isCosigner[cosigner]) revert InvalidCosigner();

        uint256 commitId = packs.length;
        uint256 userCounter = packCount[receiver_]++;

        commitBalance += amount;

        CommitData memory commitData = CommitData({
            id: commitId,
            receiver: receiver_,
            cosigner: cosigner_,
            seed: seed_,
            counter: userCounter,
            packPrice: amount,
            payoutBps: payoutBps,
            buckets: buckets_,
            packHash: packHash
        });

        packs.push(commitData);
        commitExpiresAt[commitId] = block.timestamp + commitExpireTime;

        bytes32 digest = hash(commitData);
        commitIdByDigest[digest] = commitId;

        emit Commit(msg.sender, commitId, receiver_, cosigner_, seed_, userCounter, amount, packHash, digest);

        return commitId;
    }

    /// @notice Fulfills a commit with the result of the random number generation
    /// @param commitId_ ID of the commit to fulfill
    /// @param marketplace_ Address where the order should be executed
    /// @param orderData_ Calldata for the order execution
    /// @param orderAmount_ Amount of ETH to send with the order
    /// @param token_ Address of the token being transferred (zero address for ETH)
    /// @param tokenId_ ID of the token if it's an NFT
    /// @param signature_ Signature used for random number generation (and to validate orderData)
    /// @param receiverSignature_ Signature used for receiver's choice
    /// @param payout_ Amount of ETH sent to user if they choose payout
    /// @dev Emits a Fulfillment event on success
    function fulfill(
        uint256 commitId_,
        uint256 packPrice_,
        BucketData[] memory buckets_,
        uint256 bucketIndex_,
        address marketplace_,
        bytes calldata orderData_,
        uint256 orderAmount_,
        address token_,
        uint256 tokenId_,
        bytes calldata signature_, // cosigner signed orderData
        bytes calldata signatureTwo_, // cosigner signed commitData
        bytes calldata receiverSignature_, // receiver signed choice
        uint256 payout_
    ) public payable whenNotPaused {
        _fulfill(
            commitId_,
            packPrice_,
            buckets_,
            bucketIndex_,
            marketplace_,
            orderData_,
            orderAmount_,
            token_,
            tokenId_,
            signature_,
            signatureTwo_,
            receiverSignature_,
            payout_
        );
    }

    function _fulfill(
        uint256 commitId_,
        uint256 packPrice_,
        BucketData[] memory buckets_,
        uint256 bucketIndex_,
        address marketplace_,
        bytes calldata orderData_,
        uint256 orderAmount_,
        address token_,
        uint256 tokenId_,
        bytes calldata signature_, // This needs to be the signed commitDigest
        bytes calldata signatureTwo_,
        bytes calldata receiverSignature_,
        uint256 payout_
    ) internal nonReentrant {
        // validate tx
        if (msg.value > 0) _depositTreasury(msg.value);
        if (orderAmount_ > treasuryBalance) revert InsufficientBalance();
        if (isFulfilled[commitId_]) revert AlreadyFulfilled();
        if (isExpired[commitId_]) revert CommitIsExpired();
        if (commitId_ >= packs.length) revert InvalidCommitId();

        // mark the commit as fulfilled
        isFulfilled[commitId_] = true;

        // validate commit data matches fulfill data
        CommitData memory commitData = packs[commitId_];

        // Validate the pack hash (checks that the pack price and buckets are the same as the commit)
        // TODO: Potentially superfluous if we check the cosigner signs the commit digest
        if (commitData.packHash != hashPack(packPrice_, buckets_)) revert InvalidPackHash();

        // Verify orderHash was signed by cosigner
        bytes32 orderHash = hashOrder(marketplace_, orderAmount_, orderData_, token_, tokenId_);
        address cosigner = _verifyOrderHash(orderHash, receiverSignature_);
        if (cosigner != commitData.cosigner) revert InvalidCosigner();
        if (!isCosigner[cosigner]) revert InvalidCosigner();

        // hash commit, check signature. digest is needed later for logging
        // TODO: Hash orderData and commitData together to check one signature instead of two
        bytes32 digest = hash(commitData);
        address cosignerTwo = _verifyDigest(digest, signatureTwo_);
        if (cosignerTwo != commitData.cosigner) revert InvalidCosigner();
        if (!isCosigner[cosignerTwo]) revert InvalidCosigner();

        // Collect the commit balance
        // transfer the commit balance to the contract
        treasuryBalance += commitData.amount;
        commitBalance -= commitData.amount;

        // TODO: Check that the reciever signed the choice
        address receiver = _verifyDigest(digest, receiverSignature_);
        if (receiver != commitData.receiver) revert InvalidReceiver();

        // TODO: We need to validate that given the same commit bucket array param and signature the same bucket is selected
        // on chain as the off chain parameters passed in to this function
        uint256 rng = PRNG.rng(signature_);

        uint256 bucketIndex;
        for (uint256 i = 0; i < buckets_.length; i++) {
            if (rng < buckets_[i].odds) {
                bucketIndex = i;
                break;
            }
        }
        if (bucketIndex != bucketIndex_) revert InvalidBucketIndex();

        // TODO: Ensure that orderAmount is within bucket range
        BucketData memory bucket = buckets_[bucketIndex];
        if (orderAmount_ < bucket.minValue) revert InvalidAmount();
        if (orderAmount_ > bucket.maxValue) revert InvalidAmount();

        // TODO: Handle user choice and fulfil order or payout
        if (payout_ == 0) {
            // User selected NFT
            // execute the market data to transfer the nft
            bool success = _fulfillOrder(marketplace_, orderData_, orderAmount_);
            if (success) {
                // subtract the order amount from the contract balance
                treasuryBalance -= orderAmount_;
                // emit a success transfer for the nft
                emit Fulfillment(
                    msg.sender,
                    commitData.id,
                    rng,
                    bucket.odds,
                    bucketIndex_,
                    payout_,
                    token_,
                    tokenId_,
                    orderAmount_,
                    commitData.receiver,
                    digest
                );
            } else {
                // The order failed to fulfill, it could be bought already or invalid, make the best effort to send the user the value of the order they won.
                (bool success,) = commitData.receiver.call{value: orderAmount_}("");
                if (success) {
                    treasuryBalance -= orderAmount_;
                } else {
                    emit TransferFailure(commitData.id, commitData.receiver, orderAmount_, digest);
                }
                // emit the failure (they wanted the NFT but got the payout)
                emit Fulfillment(
                    msg.sender,
                    commitId_,
                    rng,
                    bucket.odds,
                    bucketIndex_,
                    payout_,
                    address(0),
                    0,
                    0,
                    commitData.receiver,
                    digest
                );
            }
        } else {
            // User selected payout
            // TODO: Handle payout
            (bool success,) = commitData.receiver.call{value: orderAmount_}("");
            if (success) {
                treasuryBalance -= orderAmount_;
            } else {
                emit TransferFailure(commitData.id, commitData.receiver, orderAmount_, digest);
            }
            // emit the payout
            emit Fulfillment(
                msg.sender,
                commitId_,
                rng,
                bucket.odds,
                bucketIndex_,
                payout_,
                address(0),
                0,
                0,
                commitData.receiver,
                digest
            );
        }
    }

    /// @notice Fulfills a commit with the result of the random number generation
    /// @param commitDigest_ Digest of the commit to fulfill
    /// @param packPrice_ Price of the pack
    /// @param buckets_ Buckets used in the pack
    /// @param bucketIndex_ Index of the bucket to fulfill
    /// @param marketplace_ Address where the order should be executed
    /// @param orderData_ Calldata for the order execution
    /// @param orderAmount_ Amount of ETH to send with the order
    /// @param token_ Address of the token being transferred (zero address for ETH)
    /// @param tokenId_ ID of the token if it's an NFT
    /// @param signature_ Signature used for random number generation
    /// @param signatureTwo_ Signature used for commit data
    /// @param receiverSignature_ Signature used for receiver's choice
    /// @param payout_ Amount of ETH sent to user if they choose payout
    /// @dev Emits a Fulfillment event on success
    function fulfillByDigest(
        bytes32 commitDigest_,
        uint256 packPrice_,
        BucketData[] memory buckets_,
        uint256 bucketIndex_,
        address marketplace_,
        bytes calldata orderData_,
        uint256 orderAmount_,
        address token_,
        uint256 tokenId_,
        bytes calldata signature_,
        bytes calldata signatureTwo_,
        bytes calldata receiverSignature_,
        uint256 payout_
    ) public payable whenNotPaused {
        return fulfill(
            commitIdByDigest[commitDigest_],
            packPrice_,
            buckets_,
            bucketIndex_,
            marketplace_,
            orderData_,
            orderAmount_,
            token_,
            tokenId_,
            signature_
        );
    }

    /// @notice Allows the admin to withdraw ETH from the contract balance
    /// @param amount The amount of ETH to withdraw
    /// @dev Only callable by admin role
    /// @dev Emits a Withdrawal event
    function withdraw(uint256 amount) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {
        if (amount > treasuryBalance) revert InsufficientBalance();
        treasuryBalance -= amount;

        (bool success,) = payable(feeReceiver).call{value: amount}("");
        if (!success) revert WithdrawalFailed();

        emit Withdrawal(msg.sender, amount, feeReceiver);
    }

    /// @notice Allows the admin to withdraw all ETH from the contract
    /// @dev Only callable by admin role
    /// @dev Emits a Withdrawal event
    function emergencyWithdraw() external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {
        treasuryBalance = 0;
        commitBalance = 0;

        uint256 currentBalance = address(this).balance;

        _rescueETH(feeReceiver, currentBalance);

        _pause();
        emit Withdrawal(msg.sender, currentBalance, feeReceiver);
    }

    /// @notice Allows the commit owner to expire a commit in the event that the commit is not or cannot be fulfilled
    /// @param commitId_ ID of the commit to expire
    /// @dev Only callable by the commit owner
    /// @dev Emits a CommitExpired event
    function expire(uint256 commitId_) external onlyCommitOwnerOrCosigner(commitId_) nonReentrant {
        if (commitId_ >= packs.length) revert InvalidCommitId();
        if (isFulfilled[commitId_]) revert AlreadyFulfilled();
        if (isExpired[commitId_]) revert CommitIsExpired();
        if (block.timestamp < commitExpiresAt[commitId_]) {
            revert CommitNotExpired();
        }

        isExpired[commitId_] = true;

        CommitData memory commitData = packs[commitId_];

        uint256 commitAmount = commitData.amount;
        commitBalance -= commitAmount;

        uint256 transferAmount = commitAmount;

        (bool success,) = payable(commitData.receiver).call{value: transferAmount}("");
        if (!success) {
            treasuryBalance += transferAmount;
            emit TransferFailure(commitId_, commitData.receiver, transferAmount, hash(commitData));
        }

        emit CommitExpired(commitId_, hash(commitData));
    }

    // ############################################################
    // ############ RESCUE FUNCTIONS ############
    // ############################################################

    function rescueERC20(address token, address to, uint256 amount) external onlyRole(RESCUE_ROLE) {
        address[] memory tokens = new address[](1);
        address[] memory tos = new address[](1);
        uint256[] memory amounts = new uint256[](1);

        tokens[0] = token;
        tos[0] = to;
        amounts[0] = amount;

        _rescueERC20Batch(tokens, tos, amounts);
    }

    function rescueERC721(address token, address to, uint256 tokenId) external onlyRole(RESCUE_ROLE) {
        address[] memory tokens = new address[](1);
        address[] memory tos = new address[](1);
        uint256[] memory tokenIds = new uint256[](1);

        tokens[0] = token;
        tos[0] = to;
        tokenIds[0] = tokenId;

        _rescueERC721Batch(tokens, tos, tokenIds);
    }

    function rescueERC1155(address token, address to, uint256 tokenId, uint256 amount) external onlyRole(RESCUE_ROLE) {
        address[] memory tokens = new address[](1);
        address[] memory tos = new address[](1);
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory amounts = new uint256[](1);

        tokens[0] = token;
        tos[0] = to;
        tokenIds[0] = tokenId;
        amounts[0] = amount;

        _rescueERC1155Batch(tokens, tos, tokenIds, amounts);
    }

    function rescueERC20Batch(address[] calldata tokens, address[] calldata tos, uint256[] calldata amounts)
        external
        onlyRole(RESCUE_ROLE)
    {
        _rescueERC20Batch(tokens, tos, amounts);
    }

    function rescueERC721Batch(address[] calldata tokens, address[] calldata tos, uint256[] calldata tokenIds)
        external
        onlyRole(RESCUE_ROLE)
    {
        _rescueERC721Batch(tokens, tos, tokenIds);
    }

    function rescueERC1155Batch(
        address[] calldata tokens,
        address[] calldata tos,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts
    ) external onlyRole(RESCUE_ROLE) {
        _rescueERC1155Batch(tokens, tos, tokenIds, amounts);
    }

    // ############################################################
    // ############ GETTERS & SETTERS ############
    // ############################################################

    /// @notice Adds a new authorized cosigner
    /// @param cosigner_ Address to add as cosigner
    /// @dev Only callable by admin role
    /// @dev Emits a CoSignerAdded event
    function addCosigner(address cosigner_) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (cosigner_ == address(0)) revert InvalidCosigner();
        if (isCosigner[cosigner_]) revert AlreadyCosigner();
        isCosigner[cosigner_] = true;
        emit CosignerAdded(cosigner_);
    }

    /// @notice Removes an authorized cosigner
    /// @param cosigner_ Address to remove as cosigner
    /// @dev Only callable by admin role
    /// @dev Emits a CoSignerRemoved event
    function removeCosigner(address cosigner_) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (!isCosigner[cosigner_]) revert InvalidCosigner();
        isCosigner[cosigner_] = false;
        emit CosignerRemoved(cosigner_);
    }

    /// @notice Sets the commit expire time.
    /// @param commitExpireTime_ New commit expire time
    /// @dev Only callable by admin role
    /// @dev Emits a CommitExpireTimeUpdated event
    function setCommitExpireTime(uint256 commitExpireTime_) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (commitExpireTime_ < MIN_COMMIT_EXPIRE_TIME) {
            revert InvalidCommitExpireTime();
        }
        uint256 oldCommitExpireTime = commitExpireTime;
        commitExpireTime = commitExpireTime_;
        emit CommitExpireTimeUpdated(oldCommitExpireTime, commitExpireTime_);
    }

    /// @notice Sets the maximum allowed reward
    /// @param maxReward_ New maximum reward value
    /// @dev Only callable by admin role
    function setMaxReward(uint256 maxReward_) external onlyRole(OPS_ROLE) {
        if (maxReward_ < minReward) revert InvalidReward();

        uint256 oldMaxReward = maxReward;
        maxReward = maxReward_;
        emit MaxRewardUpdated(oldMaxReward, maxReward_);
    }

    /// @notice Sets the minimum allowed reward
    /// @param minReward_ New minimum reward value
    /// @dev Only callable by admin role
    function setMinReward(uint256 minReward_) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (minReward_ > maxReward) revert InvalidReward();
        if (minReward_ < minReward) revert InvalidReward();

        uint256 oldMinReward = minReward;
        minReward = minReward_;

        emit MinRewardUpdated(oldMinReward, minReward_);
    }

    /// @notice Deposits ETH into the treasury
    /// @dev Called internally when receiving ETH
    /// @param amount Amount of ETH to deposit
    function _depositTreasury(uint256 amount) internal {
        treasuryBalance += amount;
        emit Deposit(msg.sender, amount);
    }

    /// @notice Pauses the contract
    /// @dev Only callable by admin role
    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }

    /// @notice Handles receiving ETH
    /// @dev Required for contract to receive ETH
    receive() external payable {
        _depositTreasury(msg.value);
    }

    /// @notice Fulfills an order with the specified parameters
    /// @dev Internal function called by fulfill()
    /// @param to Address to send the transaction to
    /// @param data Calldata for the transaction
    /// @param amount Amount of ETH to send
    /// @return success Whether the transaction was successful
    function _fulfillOrder(address to, bytes calldata data, uint256 amount) internal returns (bool success) {
        (success,) = to.call{value: amount}(data);
    }

    /// @notice Transfers the fee receiver manager role
    /// @param newFeeReceiverManager_ New fee receiver manager
    /// @dev Only callable by fee receiver manager role
    function transferFeeReceiverManager(address newFeeReceiverManager_) external onlyRole(FEE_RECEIVER_MANAGER_ROLE) {
        if (newFeeReceiverManager_ == address(0)) {
            revert InvalidFeeReceiverManager();
        }
        _transferFeeReceiverManager(newFeeReceiverManager_);
    }

    /// @notice Transfers the fee receiver manager role
    /// @param newFeeReceiverManager_ New fee receiver manager
    function _transferFeeReceiverManager(address newFeeReceiverManager_) internal {
        _revokeRole(FEE_RECEIVER_MANAGER_ROLE, msg.sender);
        _grantRole(FEE_RECEIVER_MANAGER_ROLE, newFeeReceiverManager_);
        emit FeeReceiverManagerTransferred(msg.sender, newFeeReceiverManager_);
    }

    /// @notice Sets the fee receiver
    /// @param feeReceiver_ Address to set as fee receiver
    /// @dev Only callable by fee receiver manager role
    function setFeeReceiver(address feeReceiver_) external onlyRole(FEE_RECEIVER_MANAGER_ROLE) {
        _setFeeReceiver(feeReceiver_);
    }

    /// @notice Sets the fee receiver
    /// @param feeReceiver_ Address to set as fee receiver
    function _setFeeReceiver(address feeReceiver_) internal {
        if (feeReceiver_ == address(0)) revert InvalidFeeReceiver();
        if (hasRole(FEE_RECEIVER_MANAGER_ROLE, feeReceiver_)) {
            revert InvalidFeeReceiverManager();
        }
        address oldFeeReceiver = feeReceiver;
        feeReceiver = payable(feeReceiver_);
        emit FeeReceiverUpdated(oldFeeReceiver, feeReceiver_);
    }
    
    /// TODO: Bucket util, return index 0 as default?
    /// @notice Calculate which bucket would be selected for a given RNG value
    /// @param rng RNG value (0-10000)
    /// @param buckets Array of bucket data
    /// @return bucketIndex Index of the selected bucket
    function calculateBucketIndex(uint256 rng, BucketData[] memory buckets) 
        public 
        pure 
        returns (uint256 bucketIndex) 
    {
        for (uint256 i = 0; i < buckets.length; i++) {
            if (rng < buckets[i].odds) {
                return i;
            }
        }
        revert("No bucket selected");
    }
}
